(define (id x) x)
(define (all f l)
  (if (null? l)
    #t
    (if (f (car l))
      (all f (cdr l))
      #f)))
(define (any f l) (not (all (lambda (x) (not (f x))) l)))
(define (zip . ls)
  (if (all pair? ls)
   (cons (map car ls) (apply zip (map cdr ls)))
   '()))
(define (compose . fs)
  (if (null? fs)
    (lambda (x) x)
    (lambda (x) ((apply compose (cdr fs)) ((car fs) x)))))
(define (pipe value . fs)
  ((apply compose fs) value))
(define (split pred l)
  (if (null? l)
    '()
    (if (pred (car l))
      (cons '() (split pred (cdr l)))
      (if (null? (cdr l))
        (list l)
        (let ((rest (split pred (cdr l))))
          (cons (cons (car l) (car rest)) (cdr rest)))))))
(define (whitespace c) (or (equal? c #\newline) (equal? c #\space)))
(define (words s)
  (filter
    (lambda (s) (> (string-length s) 0))
    (map list->string (split whitespace (string->list s)))))
(define (numbers s)
  (map string->number (words s)))
(define (list-remove-tail n l) (reverse (list-tail (reverse l) n)))
(define (window n l)
  (cond
    ((eq? n 1) (map list l))
    (else (map
      (partial cons)
      (list-remove-tail (- n 1) l)
      (window (- n 1) (cdr l))))))
(define (partial f . bound) (lambda rest (apply f (append bound rest))))
(define (split-on n l)
  (if (eq? n 0)
    (list '() l)
    (let ((split-tl (split-on (- n 1) (cdr l))))
      (list
        (cons (car l) (car split-tl))
        (cadr split-tl)))))
(define (groups n l)
  (if (null? l)
    '()
    (let ((split (split-on n l)))
      (cons (car split) (groups n (cadr split))))))
(define (fold f init l)
  (if (null? l)
    init
    (fold f (f init (car l)) (cdr l))))
(define (alist-update-default k default update l)
  (cond
    ((null? l) (list (list k (update default))))
    ((equal? (caar l) k)
      (cons (list k (update (cadar l))) (cdr l)))
    (else (cons (car l) (alist-update-default k default update (cdr l))))))
(define (freqs l)
  (fold
    (lambda
      (counts item)
      (alist-update-default item 0 (partial + 1) counts))
    '()
    l))
(define (max-by key l)
  (letrec
    ((max-by-aux (lambda (max-seen l)
      (cond
        ((null? l) max-seen)
        ((> (key (car l)) (key max-seen)) (max-by-aux (car l) (cdr l)))
        (else (max-by-aux max-seen (cdr l)))))))
    (max-by-aux (car l) (cdr l))))
(define char->number (compose string string->number))
(define (char-list->number base l)
  (letrec ((helper (lambda (earlier-digits l)
      (if (null? l)
        earlier-digits
        (helper (+ (* earlier-digits base) (pipe l car char->number)) (cdr l))))))
    (helper 0 l)))
(define (filter f l)
  (reverse
    (fold
      (lambda (seen element)
        (if (f element)
          (cons element seen)
          seen))
      '()
      l)))
(define (by-freq most-or-least l)
  (car
    (max-by
      (if (equal? most-or-least 'most) cadr (compose cadr -))
      (freqs l))))
(define (until-one f l)
  (letrec ((until-one-aux
      (lambda (round l)
        (if (null? (cdr l))
          (car l)
          (until-one-aux
            (+ round 1)
            (f round l))))))
    (until-one-aux 0 l)))
(define range
  (case-lambda
    ((b e s) (letrec ((range-aux (lambda (l b e)
      (if (eq? b e)
        l
        (range-aux (cons b l) (+ b s) e)))))
    (range-aux '() b e)))
    ((e) (range 0 e 1))
    ((b e) (range b e 1))))
(define (repeat n x) (map (lambda (y) x) (range 0 n)))
(define (first-sublist f l)
  (cond
    ((null? l) l)
    ((f (car l)) l)
    (else (first-sublist f (cdr l)))))
(define (sign x) (cond
  ((> x 0) 1)
  ((< x 0) -1)
  (else 0)))
(define (sum xs) (fold + 0 xs))
(define (median nums)
  (list-ref
    (list-sort < nums)
    (floor (/ (length nums) 2))))
(define (mean nums)
  (/
    (sum nums)
    (length nums)))
(define (debug x)
  (newline)
  (display x)
  (newline)
  x)