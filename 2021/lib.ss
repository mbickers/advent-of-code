(define (all f l)
  (if (null? l)
    #t
    (if (f (car l))
      (all f (cdr l))
      #f)))
(define (zip . ls)
  (if (all pair? ls)
   (cons (map car ls) (apply zip (map cdr ls)))
   '()))
(define (pipe value . fs)
  (if (null? fs)
    value
    (apply pipe ((car fs) value) (cdr fs))))
(define (split pred l)
  (if (null? l)
    '()
    (if (pred (car l))
      (cons '() (split pred (cdr l)))
      (if (null? (cdr l))
        (list l)
        (let ((rest (split pred (cdr l))))
          (cons (cons (car l) (car rest)) (cdr rest)))))))
(define (whitespace c) (or (equal? c #\newline) (equal? c #\space)))
(define (words s)
  (map list->string (split whitespace (string->list s))))
(define (numbers s)
  (map string->number (words s)))
(define (list-remove-tail n l) (reverse (list-tail (reverse l) n)))
(define (window n l)
  (cond
    ((eq? n 1) (map list l))
    (else (map
      (partial cons)
      (list-remove-tail (- n 1) l)
      (window (- n 1) (cdr l))))))
(define (partial f . bound) (lambda rest (apply f (append bound rest))))
(define (split-on n l)
  (if (eq? n 0)
    (list '() l)
    (let ((split-tl (split-on (- n 1) (cdr l))))
      (list
        (cons (car l) (car split-tl))
        (cadr split-tl)))))
(define (groups n l)
  (if (null? l)
    '()
    (let ((split (split-on n l)))
      (cons (car split) (groups n (cadr split))))))