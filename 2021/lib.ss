(define (all f l)
  (if (null? l)
    #t
    (if (f (car l))
      (all f (cdr l))
      #f)))
(define (zip . ls)
  (if (all pair? ls)
   (cons (map car ls) (apply zip (map cdr ls)))
   '()))
(define (pipe value . fs)
  (if (null? fs)
    value
    (apply pipe ((car fs) value) (cdr fs))))
(define (split sep l)
  (if (null? l)
    '()
    (if (equal? (car l) sep)
      (cons '() (split sep (cdr l)))
      (if (null? (cdr l))
        (list l)
        (let ((rest (split sep (cdr l))))
          (cons (cons (car l) (car rest)) (cdr rest)))))))
(define (lines s)
  (map list->string (split #\newline (string->list s))))
(define (numbers s)
  (map string->number (lines s)))
(define (list-remove-tail n l) (reverse (list-tail (reverse l) n)))
(define (window n l)
  (cond
    ((eq? n 1) (map list l))
    (else (map
      (partial cons)
      (list-remove-tail (- n 1) l)
      (window (- n 1) (cdr l))))))
(define (partial f . bound) (lambda rest (apply f (append bound rest))))